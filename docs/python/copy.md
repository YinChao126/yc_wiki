# 数据复制的细节（仍然没理解）

作者：尹超

日期：2019-7-1

描述：本文详细介绍了数据拷贝的问题，从理论上揭示了浅拷贝和深拷贝

## 基础介绍

赋值(assignment)，  a = b的过程，给变量b取个别名叫a，并非真正的拷贝，两者仍然共用相同内存，速度快

浅复制（shallow copy）：新建一个对象，但是对象的元素不拷贝（没看懂）

深复制(deep copy)：真正的内存拷贝，拷贝完成后互不干扰，但可能带来很大开销

## 万变不离其宗的copy准则

以a = b为例，

python的赋值语句并不会对b进行拷贝，仅仅只是将a指向对象b所在的内存。

- 如果b是一个不可修改的对象，a指向了一块确定的内存，这就是标准的赋值动作，怎么样都不会出错。

- 如果b是一个复合对象，就需要考虑浅复制和深复制的区别了。


原则是：**拷贝对象是可变对象，则为浅复制**，否则为深复制。

可变对象包括：列表、字典、集合等

## 常见复制方法

```python
a = b #最大的坑，有可能是浅复制，也可能是深复制
a = b[:]
a = b.copy()
a = copy.copy(b) #浅复制
a = copy.deepcopy(b) #深复制
#实际使用时发现，除了第一种方法会出问题，后面都是一样的效果，而且肯定不出错
```

## 详解区别

简单"="赋值

```python
a = [1,2,3]
b = a
print(id(a),id(b)) #a和b一样, 说明两者其实就是一个东西
a[0] = 0
print(b) #b = [0,2,3] ,被动改变，bug之源！！！
#如果a为不可变对象，则不会出问题
```

浅复制

```python
a = [1,2,3,4,5,6,7]
b = copy.copy(a)
print(id(a),id(b)) #a和b不一样
print(id(a[1]),id(b[1])) #子元素一样
```

深复制

```python
a = [1,2,3,4,5,6,7]
b = copy.deepcopy(a)
print(id(a),id(b)) #a和b不一样
print(id(a[1]),id(b[1])) #子元素一样
```

## 实战要领

使用“=”来复制的时候要小心了，如果复制了可变类型数据，则很可能出错

使用copy模块你总是可以正确复制任何数据，不要管是否存在浅复制的问题

## 后记

网上看了一个小时资料，仍然没搞明白浅复制和深复制的真正区别

- 从实际使用情况来看，就是没区别
- 从理论上看，如果浅复制的元素和原对象共用同一块内存，那为啥原对象改变后，浅复制的值不变？

参考链接

[python关于copy的官方解释](https://docs.python.org/3/library/copy.html)

